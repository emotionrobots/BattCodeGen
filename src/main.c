#include <stdio.h>
#include <stdlib.h>
#include <batt_model.h>


#if 0
/* Declarations from the generated file "model.c" */
int rhs_(const double** arg, double** res, int* iw, double* w, void* mem);
int alg_(const double** arg, double** res, int* iw, double* w, void* mem);
int jac_rhs(const double** arg, double** res, int* iw, double* w, void* mem);
int jac_alg(const double** arg, double** res, int* iw, double* w, void* mem);
int x0(const double** arg, double** res, int* iw, double* w, void* mem);
int z0(const double** arg, double** res, int* iw, double* w, void* mem);
int variables(const double** arg, double** res, int* iw, double* w, void* mem);

/* Size/introspection helpers generated by CasADi */
int rhs__n_in(void);      int rhs__n_out(void);
void rhs__work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
int alg__n_in(void);      int alg__n_out(void);
void alg__work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
void x0_work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
void z0_work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
void variables_work(int* sz_arg, int* sz_res, int* sz_iw, int* sz_w);
/* ... similarly for jac_rhs, jac_alg if you plan to use them */
#endif


int main(void) 
{
    /* ==== 1) Prepare problem sizes and workspaces (reuse across calls) ==== */
    casadi_int sz_arg, sz_res, sz_iw, sz_w;

    /* Query the largest workspace among functions weâ€™ll call */
    casadi_int max_arg=0, max_res=0, max_iw=0, max_w=0;


    rhs__work(&sz_arg,&sz_res,&sz_iw,&sz_w);
    if (sz_arg>max_arg) max_arg=sz_arg; 
    if (sz_res>max_res) max_res=sz_res;
    if (sz_iw>max_iw) max_iw=sz_iw;     
    if (sz_w>max_w)   max_w=sz_w;

    alg__work(&sz_arg,&sz_res,&sz_iw,&sz_w);
    if (sz_arg>max_arg) max_arg=sz_arg; 
    if (sz_res>max_res) max_res=sz_res;
    if (sz_iw>max_iw) max_iw=sz_iw;     
    if (sz_w>max_w)   max_w=sz_w;

    x0_work(&sz_arg,&sz_res,&sz_iw,&sz_w);
    if (sz_arg>max_arg) max_arg=sz_arg; 
    if (sz_res>max_res) max_res=sz_res;
    if (sz_iw>max_iw) max_iw=sz_iw;     
    if (sz_w>max_w)   max_w=sz_w;

    z0_work(&sz_arg,&sz_res,&sz_iw,&sz_w);
    if (sz_arg>max_arg) max_arg=sz_arg; 
    if (sz_res>max_res) max_res=sz_res;
    if (sz_iw>max_iw) max_iw=sz_iw;     
    if (sz_w>max_w)   max_w=sz_w;

    variables_work(&sz_arg,&sz_res,&sz_iw,&sz_w);
    if (sz_arg>max_arg) max_arg=sz_arg; 
    if (sz_res>max_res) max_res=sz_res;
    if (sz_iw>max_iw) max_iw=sz_iw;     
    if (sz_w>max_w)   max_w=sz_w;

    const casadi_real** arg = (const casadi_real**)calloc((size_t)max_arg, sizeof(*arg));
    casadi_real** res = (casadi_real **)calloc((size_t)max_res, sizeof(*res));
    casadi_int* iw = (casadi_int *)calloc((size_t)max_iw, sizeof(*iw));
    casadi_real* w  = (casadi_real *)calloc((size_t)max_w, sizeof(*w));
    int mem = 0;

    printf("Step 1\n");

    /* ==== 2) Build the inputs (t, x, z, p) ====
       You must set the lengths correctly for your model.
       Let nx = len(x), nz = len(z), np = len(p). */
    casadi_real t = 0.0;
    /* Typically you learn nx, nz by examining the generated file or by printing
       sizes from Python before codegen. */
    /* Example placeholders: */
    // enum { nx = /*...*/ 1, nz = /*...*/ 1, np = /*...*/ 1 };

    // Query the number of differential states (nx), algebraic states (nz) and
    // input parameters (np)
    casadi_int nx = rhs__sparsity_in(1)[0];
    casadi_int nz = rhs__sparsity_in(2)[0];
    casadi_int np = rhs__sparsity_in(3)[0];

    casadi_real x[nx], z[nz], p[np];

    printf("Step 2\n");

    /* Fill p[...] in the SAME ORDER you used in input_parameter_order when generating */
    /* p[0] = ...; */

    /* ==== 3) Get x0 and z0 from the generated functions ==== */
    {
      /* x0 takes only 'p' as input; its arg[0]=p; res[0]=x */
      arg[0] = p;  
      res[0] = x;
      if (x0(arg, res, iw, w, mem)) 
      { 
	      fprintf(stderr,"x0 failed\n"); 
	      return 1; 
      }

      /* z0 similarly */
      arg[0] = p;  
      res[0] = z;
      if (z0(arg, res, iw, w, mem)) 
      { 
	      fprintf(stderr,"z0 failed\n"); 
	      return 1; 
      }
    }

    printf("Step 3\n");

    /* If you need to ensure algebraic consistency at t=0:
       iterate a small rootfinder on alg_(t,x,z,p) to drive it ~0. */

    /* ==== 4) Evaluate rhs_ and alg_ (e.g., inside a time-step/DAE solver) ==== */
    {
      /* rhs_: arg = [t, x, z, p]; res[0] points to dxdt */
      casadi_real dxdt[nx];
      arg[0] = &t;  
      arg[1] = x;  
      arg[2] = z;  
      arg[3] = p;
      res[0] = dxdt;
      if (rhs_(arg, res, iw, w, mem)) 
      { 
	      fprintf(stderr,"rhs_ failed\n"); 
	      return 1; 
      }

      /* alg_: residual vector r = g(t,x,z,p) */
      casadi_real r[nz];
      arg[0] = &t;  
      arg[1] = x;  
      arg[2] = z;  
      arg[3] = p;
      res[0] = r;
      if (alg_(arg, res, iw, w, mem)) { 
	      fprintf(stderr,"alg_ failed\n"); 
	      return 1; 
      }
    }

    printf("Step 4\n");

    /* ==== 5) Read derived outputs with variables(...) (stacked) ==== */
    {
      // 'variables_sparsity_out(0)' returns a pointer to a sparsity description
      // The first element [0] is the number of rows = the length of the variable vector
      casadi_int nvar = variables_sparsity_out(0)[0];
      printf("nvar = %lld\n", nvar);
      casadi_real var_out[nvar];
      arg[0] = &t; 
      arg[1] = x; 
      arg[2] = z; 
      arg[3] = p;
      res[0] = var_out;
      if (variables(arg, res, iw, w, mem)) 
      { 
	      fprintf(stderr,"variables failed\n"); 
	      return 1; 
      }
      /* var_out[0], var_out[1], ... match your variable_names order */
    }

    printf("Step 5\n");

    free(arg); 
    free(res); 
    free(iw); 
    free(w);

    printf("Step 6\n");
    return 0;
}

